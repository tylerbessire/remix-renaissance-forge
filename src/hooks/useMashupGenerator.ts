import { useState, useRef, useCallback } from "react";
import { supabase } from "@/integrations/supabase/client";
import { toast } from "sonner";

// --- Interface Definitions ---
interface Song {
  id: string;
  name: string;
  artist: string;
  file: File;
}

interface UploadedSong {
  storage_path: string;
  song_id: string;
  name: string;
  artist: string;
}

interface MashupResult {
  title: string;
  concept: string;
  audioUrl: string;
}

// New interfaces for async flow
interface MashupJobResponse {
  success: boolean;
  jobId: string;
}

interface MashupStatusData {
  status: 'processing' | 'complete' | 'failed';
  result_url?: string;
  title?: string;
  concept?: string;
  error_message?: string;
}

const sanitizeFilename = (filename: string): string => {
  return filename.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9-_\.]/g, '');
};

export const useMashupGenerator = () => {
  const [isProcessing, setIsProcessing] = useState(false);
  const [progress, setProgress] = useState(0);
  const [processingStep, setProcessingStep] = useState("");
  const [mashupResult, setMashupResult] = useState<MashupResult | null>(null);
  const pollingIntervalRef = useRef<NodeJS.Timeout | null>(null);

  const stopPolling = useCallback(() => {
    if (pollingIntervalRef.current) {
      clearInterval(pollingIntervalRef.current);
      pollingIntervalRef.current = null;
    }
  }, []);

  const uploadSong = async (song: Song): Promise<UploadedSong> => {
    if (!song.file || !(song.file instanceof File)) {
      throw new Error(`Invalid file for song "${song.name}".`);
    }
    const safeFilename = sanitizeFilename(song.file.name);
    const filePath = `uploads/${song.id}/${safeFilename}`;
    const { data: signedUpload, error: signedErr } = await supabase.functions.invoke<{ path: string; signedUrl: string; token: string }>('create-signed-upload', {
      body: { songId: song.id, fileName: safeFilename, fileSize: song.file.size, contentType: song.file.type || undefined },
    });
    if (signedErr || !signedUpload) {
      throw new Error(`Failed to prepare secure upload for ${song.name}: ${signedErr?.message || 'Unknown error'}.`);
    }
    const { error: uploadError } = await supabase.storage.from('mashups').uploadToSignedUrl(signedUpload.path, signedUpload.token, song.file);
    if (uploadError) {
      throw new Error(`Failed to upload ${song.name}: ${uploadError.message}.`);
    }
    return { storage_path: filePath, song_id: song.id, name: song.name, artist: song.artist };
  };

  const pollMashupStatus = useCallback(async (jobId: string) => {
    const { data, error } = await supabase.functions.invoke<MashupStatusData>('get-mashup-status', {
      body: { jobId },
    });

    if (error) {
      toast.error(`Error checking status: ${error.message}`);
      stopPolling();
      setIsProcessing(false);
      return;
    }

    if (!data) return;

    setProcessingStep(`AI is working... (status: ${data.status})`);

    if (data.status === 'complete') {
      stopPolling();
      setProcessingStep("Mashup complete!");
      setProgress(100);

      if (!data.result_url) {
        toast.error("Mashup finished, but no audio URL was found.");
        setIsProcessing(false);
        return;
      }

      const { data: signedUrlData, error: signedUrlError } = await supabase.storage
        .from('mashups')
        .createSignedUrl(data.result_url, 3600);

      if (signedUrlError || !signedUrlData?.signedUrl) {
          toast.error(`Could not create secure link for the mashup: ${signedUrlError?.message || 'Unknown error'}`);
          setIsProcessing(false);
          return;
      }

      const result: MashupResult = {
        title: data.title ?? 'Your AI Mashup',
        concept: data.concept ?? 'Generated by AI',
        audioUrl: signedUrlData.signedUrl,
      };
      setMashupResult(result);
      toast.success(`Created "${result.title}"!`);
      setIsProcessing(false);

    } else if (data.status === 'failed') {
      stopPolling();
      toast.error(`Mashup failed: ${data.error_message || 'Unknown error'}`);
      setIsProcessing(false);
    }
  }, [stopPolling]);

  const generateMashup = async (songs: Song[]) => {
    if (songs.length < 2 || songs.length > 3) {
      toast.error("Please provide 2-3 songs for mashup");
      return;
    }

    setIsProcessing(true);
    setMashupResult(null);
    setProgress(0);
    setProcessingStep("Uploading your tracks...");

    const { data: { session } } = await supabase.auth.getSession();
    if (!session) {
      toast.error("Please sign in to upload and generate mashups.");
      setIsProcessing(false);
      return;
    }

    try {
      const uploadedSongs = await Promise.all(songs.map(async (song, index) => {
        setProgress( (index + 1) / songs.length * 50 );
        return await uploadSong(song);
      }));

      setProcessingStep("Initializing AI mashup...");
      setProgress(60);

      const { data, error } = await supabase.functions.invoke<MashupJobResponse>('generate-mashup', {
        body: { songs: uploadedSongs }
      });

      if (error || !data?.success || !data.jobId) {
        throw new Error(`Failed to start mashup job: ${error?.message || 'No job ID returned'}`);
      }

      setProcessingStep("Mashup job started! Waiting for AI...");
      setProgress(75);

      stopPolling(); // Ensure no previous polling is running

      // Start polling
      pollingIntervalRef.current = setInterval(() => pollMashupStatus(data.jobId), 5000);
      // And call it once immediately
      pollMashupStatus(data.jobId);

    } catch (error) {
      console.error('Mashup generation error:', error);
      toast.error(error instanceof Error ? error.message : "An unknown error occurred.");
      setIsProcessing(false);
      setProgress(0);
      setProcessingStep("");
      stopPolling();
    }
  };

  return {
    generateMashup,
    isProcessing,
    progress,
    processingStep,
    mashupResult,
  };
};
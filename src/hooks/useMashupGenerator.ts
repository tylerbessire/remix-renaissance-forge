import { useState, useRef, useCallback } from "react";
import { supabase } from "@/integrations/supabase/client";
import { toast } from "sonner";
import { type MashupSection } from "@/components/MashupTimeline";

// This interface definition should be consistent with other files
interface Song {
  id: string;
  name: string;
  artist: string;
  file?: File;
  storage_path?: string;
}

interface UploadedSong {
  storage_path: string;
  song_id: string;
  name: string;
  artist: string;
}

interface MashupResult {
  title: string;
  concept: string;
  audioUrl: string;
  timeline?: MashupSection[];
}

// New interfaces for async flow
interface MashupJobResponse {
  success: boolean;
  jobId: string;
}

interface MashupStatusData {
  status: 'processing' | 'complete' | 'failed';
  progress?: number;
  currentStep?: string;
  result_url?: string;
  title?: string;
  concept?: string;
  error_message?: string;
  timeline?: MashupSection[];
  estimated_completion?: string;
  processing_time_elapsed?: string;
  error_details?: {
    type: string;
    recoverable: boolean;
    suggested_action: string;
  };
  metadata?: {
    songs_count: number;
    analyses_completed: number;
    mashability_scores_count: number;
    has_masterplan: boolean;
  };
}

const sanitizeFilename = (filename: string): string => {
  return filename.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9-_\.]/g, '');
};

export const useMashupGenerator = () => {
  const [isProcessing, setIsProcessing] = useState(false);
  const [progress, setProgress] = useState(0);
  const [processingStep, setProcessingStep] = useState("");
  const [mashupResult, setMashupResult] = useState<MashupResult | null>(null);
  const pollingIntervalRef = useRef<NodeJS.Timeout | null>(null);

  const stopPolling = useCallback(() => {
    if (pollingIntervalRef.current) {
      clearInterval(pollingIntervalRef.current);
      pollingIntervalRef.current = null;
    }
  }, []);

  const uploadSong = async (song: Song & { file: File }): Promise<UploadedSong> => {
    const safeFilename = sanitizeFilename(song.file.name);
    const filePath = `uploads/${song.id}/${safeFilename}`;
    const { data: signedUpload, error: signedErr } = await supabase.functions.invoke<{ path: string; signedUrl: string; token: string }>('create-signed-upload', {
      body: { songId: song.id, fileName: safeFilename, fileSize: song.file.size, contentType: song.file.type || undefined },
    });
    if (signedErr || !signedUpload) {
      throw new Error(`Failed to prepare secure upload for ${song.name}: ${signedErr?.message || 'Unknown error'}.`);
    }
    const { error: uploadError } = await supabase.storage.from('mashups').uploadToSignedUrl(signedUpload.path, signedUpload.token, song.file);
    if (uploadError) {
      throw new Error(`Failed to upload ${song.name}: ${uploadError.message}.`);
    }
    return { storage_path: filePath, song_id: song.id, name: song.name, artist: song.artist };
  };

  const pollMashupStatus = useCallback(async (jobId: string) => {
    const { data, error } = await supabase.functions.invoke<MashupStatusData>('get-mashup-status', {
      body: { jobId },
    });

    if (error) {
      toast.error(`Error checking status: ${error.message}`);
      stopPolling();
      setIsProcessing(false);
      return;
    }

    if (!data) return;

    // Use enhanced status information for better user feedback
    const currentStep = data.currentStep || `AI is working... (status: ${data.status})`;
    const currentProgress = data.progress || 75;
    
    setProcessingStep(currentStep);
    setProgress(currentProgress);

    // Show estimated completion time if available
    if (data.estimated_completion && data.status === 'processing') {
      setProcessingStep(`${currentStep} - Est. ${data.estimated_completion} remaining`);
    }

    if (data.status === 'complete') {
      stopPolling();
      setProcessingStep("Mashup complete!");
      setProgress(100);

      let audioUrl = '';
      
      if (data.result_url) {
        const { data: signedUrlData, error: signedUrlError } = await supabase.storage
          .from('mashups')
          .createSignedUrl(data.result_url, 3600);

        if (signedUrlError || !signedUrlData?.signedUrl) {
            toast.error(`Could not create secure link for the mashup: ${signedUrlError?.message || 'Unknown error'}`);
            setIsProcessing(false);
            return;
        }
        audioUrl = signedUrlData.signedUrl;
      } else {
        // No audio file yet - this is a demo/preview
        toast.info("Mashup concept created! Audio processing will be available soon.");
      }

      const result: MashupResult = {
        title: data.title ?? 'Your AI Mashup',
        concept: data.concept ?? 'Generated by AI',
        audioUrl: audioUrl,
        timeline: data.timeline,
      };
      setMashupResult(result);
      toast.success(`Created "${result.title}"! (Processed in ${data.processing_time_elapsed || 'unknown time'})`);
      setIsProcessing(false);

    } else if (data.status === 'failed') {
      stopPolling();
      
      // Use enhanced error information for better user guidance
      const errorMessage = data.error_details?.suggested_action 
        ? `${data.error_message || 'Unknown error'}\n\n${data.error_details.suggested_action}`
        : data.error_message || 'Unknown error';
      
      toast.error(`Mashup failed: ${errorMessage}`);
      setIsProcessing(false);
    }
  }, [stopPolling]);

  const generateMashup = async (songs: Song[]) => {
    if (songs.length < 2 || songs.length > 3) {
      toast.error("Please provide 2-3 songs for mashup");
      return;
    }

    setIsProcessing(true);
    setMashupResult(null);
    setProgress(0);
    setProcessingStep("Uploading your tracks...");

    const { data: { session } } = await supabase.auth.getSession();
    if (!session) {
      toast.error("Please sign in to upload and generate mashups.");
      setIsProcessing(false);
      return;
    }

    try {
      const uploadedSongs = await Promise.all(songs.map(async (song, index) => {
        setProgress( (index + 1) / songs.length * 50 );
        if (song.storage_path) {
          return { storage_path: song.storage_path, song_id: song.id, name: song.name, artist: song.artist };
        } else if (song.file) {
          return await uploadSong(song as Song & { file: File });
        } else {
          throw new Error(`Song "${song.name}" has no file or storage path.`);
        }
      }));

      setProcessingStep("Initializing AI mashup...");
      setProgress(60);

      const { data, error } = await supabase.functions.invoke<MashupJobResponse>('generate-mashup', {
        body: { songs: uploadedSongs }
      });

      if (error || !data?.success || !data.jobId) {
        throw new Error(`Failed to start mashup job: ${error?.message || 'No job ID returned'}`);
      }

      setProcessingStep("Mashup job started! Waiting for AI...");
      setProgress(75);

      stopPolling();

      pollingIntervalRef.current = setInterval(() => pollMashupStatus(data.jobId), 5000);
      pollMashupStatus(data.jobId);

    } catch (error) {
      console.error('Mashup generation error:', error);
      toast.error(error instanceof Error ? error.message : "An unknown error occurred.");
      setIsProcessing(false);
      setProgress(0);
      setProcessingStep("");
      stopPolling();
    }
  };

  return {
    generateMashup,
    isProcessing,
    progress,
    processingStep,
    mashupResult,
    setMashupResult,
  };
};